/*
 一。前言
# 声明，定义，（初始化）的区别
    > 声明：告诉编译器该变量（或函数声明）的存在。不分配内存，但编译器生成相应符号进入符号表。
	> 定义：说明变量（函数）的具体属性，并分配内存
	> 初始化：给变量的内存空间一个初始值，最好手动初始化，保证运行安全。
            ×需手动初始化基本变量
            ×需构造函数初始化类的内置类型(包括指针，引用)数据成员
            初始化细节见:初始化
		
# 头文件与源文件。
    > 声明与定义分开--防止连接阶段的重定义
      头文件条件编译--防止编译阶段的重定义
      头文件内容主要包括：变量的声明、  函数的声明、 类的声明及定义、宏定义等。
	  源文件内容主要包括：变量的定义、  函数的定义、 类的成员函数的定义
	
	> 重定义。编译阶段的重定义和链接阶段的重定义，使用引用性声明，防止重定义！
		× 定义性声明与引用性声明区别：
			定义性声明：c/c++变量定义时，往往声明了，如int a=0；
		    引用性声明：有时需要调用另一文件的变量或函数，定义性声明会导致重复定义问题，因为定义只能一次 ，而声明能多次，所以采用引用声明。
			    引用性声明两种方法：
					a.extern关键字：extern int a;
					b.调用包含该变量声明的头文件。(更好，但注意头文件和源文件分开写)
		
# extern关键字:储存类型关键字
	> 修饰变量或函数：实现引用性声明，扩展全局变量/函数的作用域。
	    s1: 源文件中定义
        s2：头文件中声明(如下)，其他将可include该头文件。
            extern int a;//引用性声明，可省extern
		    extern void fun(int a,int b)//引用性声明函数，可省关键字extern
	
	> extern "C":c/c++混合编译时，cpp文件按照cpp风格编译时指定该文件中的c代码(一般是c函数声明)按照c风格编译，避免“找不到xx定义”问题
	    s1: cfile.c模块编译成.o或库文件，提供相关cfile.h供其他文件调用
        s2：.cpp模块通过include cfile.h调用相关c语言函数,为了避免链接阶段由于c/c++编译风格差异性导致“找不到xx定义”问题，需在.cpp中做如下处理：
			 
				#ifdef __cpluscplus //c++源文件宏   
					extern "C" {    
				#endif    
					//c头文件
                    //或c函数声明
				#ifdef __cplusplus    
							}    
					#endif   
		
#include"ExternTest.h"//头文件自动关对应的源文件
#include <iostream> 
using namespace std;

//extern 修饰全局变量和函数，以实现夸文件调用函数和全局变量。
// 具体有两种方法：1.调用的文件中采用extern进行引用性声明，可能导致重定义。
//2.调用文件采用调用包含该被调用对象的头文件（该头文件与其源文件分开）进行引用性声明，避免重定义

//法一：采用extern关键字，进行跨文件调用（引用性声明）

//int main()
//{
//extern int i;//引用性声明，不可赋值
//extern void fun();//引用性声明
//	fun();
//	system("pause");
//	return 0;
//}

//法二：采用调用头文件，进行引用性声明


int main()
{
	i = 2; //i被包含在头文件，在该文件相当于全局变量，所以在此修改了i的值
	fun();
	
	cout << i;
	system("pause");
	return 0;
}

//extern "c"：用于c++调用c代码，应使用extern关键字，使得c代码按照c的编译器进行编译，而不是按照c++进行编译，否则按照c++进行编译，会按照c++的规则进行符号修改，
//引起在c代码中找不到该符号
//具体分两种情况：

//情况一：c的头文件已使用extern关键字，以被c或c++调用
/*
#ifdef __cpluscplus    
extern "C" {    
#endif    
    
//some code    //原c头文件
    
#ifdef __cplusplus    
}    
#endif

*/

//情况二：c的头文件未使用extern “c”，那么就在c++中使用extern “c”{c头文件}
/*
extern "c"
{
#include "test_extern_c.h"//include b包含c头文件
int ThisIsTest(int, int);//调用c函数
}

*/

