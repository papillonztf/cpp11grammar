//static关键字的用法.


/*
	一.windows c/c++内存分布：实际的内存分布和编译器有关，不必在乎其名称，注意其的内存使用对编程的影响即可。
			初步认5为内存分布有以下五种：内存区域特点---使用情形--使用注意事项
					1.栈：运行时自动分配和自动释放，（也可使用链表实现栈的动态分配），大小可修改式固定（空间很小），向下生长，即地址值减小；
						用于函数调用中的形参，局部变量，函数返回值和番薯返回地址；虽然栈不会有内存碎片问题，但应注意栈的越界（数组越界）和栈溢出（如多次函数递归）
					2.堆：程序员手动申请和释放（或程序结束os释放），运行时动态分配，大小可变（空间很大），向上生长且不连续，有内存碎片；用于使用new和malloc手动分配内存，必须程序员手动delette或free释放内存。
						如；应注意内存碎片、内存泄露，严重地导致堆溢出
					3.全局静态存储区：存放全局变量和静态变量，程序结束才自动释放。
					4.常量存储区：存放常量，如字符指针指向的字符串常量，以及const变量。const关键字，另详细讲解。
					5.代码区：存放二进制的代码
	二。static关键字：
				1.static用于面对过程的程序设计中：该情况，static的是存储类型关键字，作用是：1.限定作用域。2.延长生存周期至程序结束
						a.static局部变量：扩大生存周期，直至程序结束。但其仍保持局部作用域
										  1.存放在静态存储区（全局存储区），默认自动初始化为0。
										  2.保留局部作用域特点，但生存周期是直到整个程序结束。
										  3.块（子函数）只会在第一次初始化该变量，之后的调用该块（子函数），不会再初始化，而是继续利用该变量的上次值。
						b.static全局变量：限定全局变量的作用范围，使其只能作用于本文件，不可再使用extern。
										  1.存放在静态存储区（全局存储区），默认自动初始化为0.
										  2.保留全局作用域特点，生存周期仍是直到整个程序结束，但作用范围是只限于该文件。
										  3.无需在头文件声明static变量，因为static变量置作用于该源文件.整个程序内可重名。
						c.static函数：限定函数的作用范围，使其只能作用于本文件，不可使用extern。
										  2.保留全局作用域特点，但作用范围是只限于该文件。
										  3.即不可extern跨文件调用static函数(无需头文件中声明该static函数)，同时也使得该static函数，可重名。
				2.static用于面对对象的程序设计：该情况，static关键字的本质是，只占一份内存，且属于类，不能方法非static成员
						a.static数据成员：
                                          1.static数据成员放在静态存储区，只能初始化一次.
                                            ==> 因此，static成员变量的初始化化方式只能是定义时声明，而不能通过初始化列表进行初始化
                                          2.static数据成员在类声明头文件中只是声明，因此必须定义，
                                            而静态数据成员的定义必须在类外，且往往是在类定义的源文件中以防止连接阶段重定义
										  3.静态数据成员是类的，是所有类的对象共享的，只占一份内存，sizeof(类/对象)求得是类对象的内存大小因此是不含static成员变量的。
										  4.可通过类test：：j或者对象mytest.j进行访问（如果该是public），和修改（一改所有改）。
										  5.饿汉单例模式时，在单例类的
                                            static ySingleton× MySingleton::getInstance()
                                            {
                                                static MySingleton mySingleton;//静态变量一直存在，且多次调用该函数只初始化一次(定义一次)
                                                return &mySingleton;
                                            }
						b.static成员函数：1.只能访问静态数据/静态函数成员/函数内定义的变量；但非静态成员函数可访问静态函数成员和静态变量成员
										  2.静态函数成员是类的，是所有类的对象共享的。因此可通过类::和类对象调用该静态函数成员。
		三，具体的编程实现与分析：
				1.extern和static都是声明关键词,作用是声明下这个变量是否在该处可用，因此先static int i或static void fun（）声明后，相应的定义就不用在写上该static关键字
				2.静态数据成员的定义应该放在类外：为了保证静态数据成员只定义一次。
				3.静态数据成员的定义必须类外定义并且得放在源文件中定义：若放在头文件的类声明的类外定义，会引起重定义
				4.关于初始化：
                    × linux 未初始化的全局和静态变量(.bss段)会默认初始化为0；
                    × 栈段变量则是随机初始化，
                    × 引用/cosnt变量必须初始化
					× 类的数据成员初始化，见初始化
                    最好手动初始化
										 
*/

#include<iostream>
#include"StaticTest.h"
//
using namespace std;

int main()
{
	StatTest cStatTestObect;
	//test static global var

	cout << iGlobVar<< endl;
	//cout << isStatGlobVar << endl;//限定全局变量的作用范围，使其只能作用于本文件，不可使用extern

		
	//test static local var.
	TestStatLocVar();
	TestStatLocVar();//块（子函数）只会在第一次初始化静态局部变量，之后的调用该块（子函数），不会再初始化，而是继续利用该变量的上次值。

	//test static func
	//TestStatFunc();

	//test static var member
	StatTest::StatFun();
	cStatTestObect.StatFun();

	//test static func member
	cStatTestObect.Fun();
	system("pause");
}
