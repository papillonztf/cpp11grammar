
/*
 所有的位操作，包括移位操作，都是按补码进行运算的！需将原码转为补码进行运算
 转换规则：
    1.无符号以及正数的补码是原码;
    2.负数的补码是原码的符号位不变-其余位取反-
      末位加1;
    3.补码的补码是原码;
 位移运算：
    左移：
        无论有无符号，均将二进制补码向左移动，低位补0.
    右移：
        无符号：将补码向右移动，高位补0.
        有符号：将补码向右移动，高位全部补其符号位.正 补0,负不1.
 溢出：规定100000000000000000000000000000是最小的int 即-(1<<31）
        当最大的int，(1<<31)-1再加1,便会溢出得到最小int-(1<<31)

        有符号：0 有两个补码 10000000000000000和000000000000000000
 * */
#include<iostream>

using namespace std;

int main()
{
    int i=8;//signed int 0x00000008
    int j=-8;// 0x10000008

    unsigned int m=8;//0x00000008
    cout<<"请注意本机的位数： "<<sizeof(int)*8<<"位 "<<endl;
    cout<<"signed int   :"<<-(1<<31)<<"~"<<((1<<31)-1)<<endl;//1的补码进行运算
    cout<<"unsigned int :"<<0<<"~"<<(unsigned int)(-1)<<endl;

    //左移
    cout<<(i<<2)<<endl;
    cout<<(j<<2)<<endl;
    cout<<(m<<2)<<endl;
    //右移
    cout<<(i>>2)<<endl;
    cout<<(j>>2)<<endl;
    cout<<(m>>2)<<endl;
return 0;
}
